<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Color Maze Fill Game</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background-color: white; font-family: sans-serif; }
.game-screen { position: relative; width: 100%; height: 100%; }
.gray-section { position: absolute; bottom: 0; width: 100%; height: 75%; background-color: #555; display: flex; justify-content: center; align-items: center; }
canvas { width: 90vw; height: 65vh; max-width: 1200px; max-height: 800px; display: block; }
.ui { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; align-items: center; z-index: 10; }
.counter { color: black; font-size: 1.1rem; font-weight: bold; user-select: none; }
.control-btn { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 70px; height: 70px; border-radius: 50%; background-color: white; border: 2px solid black; cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.3); z-index: 10; transition: 0.2s; }
.control-btn:hover { transform: translateX(-50%) scale(1.1); }
</style>
</head>
<body>
<div class="game-screen">
  <div class="ui">
    <div class="counter" id="leftCounter">Left: 0%</div>
    <div class="counter" id="rightCounter">Right: 0%</div>
  </div>
  <button class="control-btn" id="generateBtn"></button>
  <div class="gray-section">
    <canvas id="mazeCanvas"></canvas>
  </div>
</div>

<script>
const canvas = document.getElementById("mazeCanvas");
const ctx = canvas.getContext("2d");
const btn = document.getElementById("generateBtn");
const leftCounterEl = document.getElementById("leftCounter");
const rightCounterEl = document.getElementById("rightCounter");

let nodes = [];
let connections = [];
let adjacency = new Map();
let dots = [];
let end1, end2, squareSize;
let leftTrips = 0;
let rightTrips = 0;
const maxTrips = 500; // trips needed to reach 100%
const minTime = 1300;
const maxTime = 3300;

function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  const scale = window.devicePixelRatio || 1;
  canvas.width = rect.width * scale;
  canvas.height = rect.height * scale;
  ctx.setTransform(scale,0,0,scale,0,0);
  setupMaze();
}

window.addEventListener("resize", resizeCanvas);
window.addEventListener("load", () => { resizeCanvas(); animate(); });

function setupMaze() {
  const w = canvas.width/(window.devicePixelRatio||1);
  const h = canvas.height/(window.devicePixelRatio||1);
  const nodeCount = 5 + Math.floor(Math.random()*11);
  nodes = [];
  adjacency.clear();
  connections = [];

  nodes.push({x: 60, y:0}); // start top-left

  for(let i=0;i<nodeCount;i++){
    nodes.push({ x: 150 + Math.random()*(w-300), y: 120 + Math.random()*(h-240) });
  }

  nodes.push({x:120, y:h-100}); // red left endpoint
  nodes.push({x:w-120, y:h-100}); // blue right endpoint
  end1 = nodes[nodes.length-2];
  end2 = nodes[nodes.length-1];
  squareSize = 200;

  for(let i=0;i<nodes.length;i++) adjacency.set(i, []);
  for(let i=0;i<nodes.length;i++){
    for(let j=i+1;j<nodes.length;j++){
      const type = Math.random()<0.5?"ortho":"diag";
      connections.push({a:nodes[i], b:nodes[j], type, i, j});
      adjacency.get(i).push(j);
      adjacency.get(j).push(i);
    }
  }
  leftTrips=0; rightTrips=0;
}

function drawMaze(){
  const w = canvas.width/(window.devicePixelRatio||1);
  const h = canvas.height/(window.devicePixelRatio||1);
  ctx.clearRect(0,0,w,h);

  // draw connections
  ctx.strokeStyle="white"; ctx.lineWidth=8;
  for(const c of connections){
    ctx.beginPath(); ctx.moveTo(c.a.x,c.a.y);
    if(c.type==="ortho"){ ctx.lineTo(c.b.x,c.a.y); ctx.lineTo(c.b.x,c.b.y); }
    else ctx.lineTo(c.b.x,c.b.y);
    ctx.stroke();
  }

  // nodes
  for(const n of nodes){
    ctx.beginPath();
    ctx.arc(n.x,n.y,6,0,Math.PI*2);
    ctx.fillStyle="white";
    ctx.fill();
  }

  // draw endpoints
  ctx.fillStyle="white";
  ctx.fillRect(end1.x-squareSize/2,end1.y-squareSize/2,squareSize,squareSize);
  ctx.fillRect(end2.x-squareSize/2,end2.y-squareSize/2,squareSize,squareSize);

  // fill red/blue proportional to trips
  const leftFill = (leftTrips/maxTrips)*squareSize;
  const rightFill = (rightTrips/maxTrips)*squareSize;
  if(leftFill>0){ ctx.fillStyle="red"; ctx.fillRect(end1.x-squareSize/2,end1.y+squareSize/2-leftFill,squareSize,leftFill);}
  if(rightFill>0){ ctx.fillStyle="blue"; ctx.fillRect(end2.x-squareSize/2,end2.y+squareSize/2-rightFill,squareSize,rightFill);}

  leftCounterEl.textContent=`Left: ${Math.min(100,Math.round(leftTrips/maxTrips*100))}%`;
  rightCounterEl.textContent=`Right: ${Math.min(100,Math.round(rightTrips/maxTrips*100))}%`;
}

function findRandomPath(startIndex,endIndex){
  const path=[startIndex];
  const visited=new Set([startIndex]);
  while(path[path.length-1]!==endIndex){
    const current=path[path.length-1];
    const neighbors=adjacency.get(current).filter(n=>!visited.has(n));
    if(neighbors.length===0) break;
    const next=neighbors[Math.floor(Math.random()*neighbors.length)];
    path.push(next); visited.add(next);
    if(path.length>15) break;
  }
  if(path[path.length-1]!==endIndex) path.push(endIndex);
  return path.map(i=>nodes[i]);
}

function addDot(){
  const goLeft = Math.random()<0.5;
  const endIndex = goLeft?nodes.length-2:nodes.length-1;
  const path=findRandomPath(0,endIndex);
  const time = minTime + Math.random()*(maxTime-minTime);
  const speed = (1/(time/16))*1.5;
  dots.push({path,progress:0,speed,forward:true,goLeft});
}

btn.addEventListener("click",addDot);

function animate(){
  drawMaze();

  for(const dot of dots){
    const segCount = dot.path.length-1;
    dot.progress += dot.speed*(dot.forward?1:-1);
    if(dot.progress>=segCount){
      dot.progress=segCount;
      dot.forward=false;
      if(dot.goLeft) leftTrips=Math.min(maxTrips,leftTrips+1);
      else rightTrips=Math.min(maxTrips,rightTrips+1);
    } else if(dot.progress<=0){
      dot.progress=0;
      dot.forward=true;
    }

    const seg=Math.floor(dot.progress);
    const t=dot.progress-seg;
    const start=dot.path[seg];
    const end=dot.path[Math.min(seg+1,segCount)];
    const x=start.x+(end.x-start.x)*t;
    const y=start.y+(end.y-start.y)*t;

    ctx.beginPath();
    ctx.arc(x,y,8,0,Math.PI*2);
    ctx.fillStyle = dot.forward ? (dot.goLeft?"red":"blue") : "black";
    ctx.fill();
  }

  requestAnimationFrame(animate);
}
</script>
</body>
</html>
